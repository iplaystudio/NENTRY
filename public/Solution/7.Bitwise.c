/*
符合规则的表达式分为三类，需分别计算其贡献并求和：
1. 全是异或运算符：仅 1 种表达式，结果为所有数的异或和。
2. 全是加减运算符：所有可能的加减表达式的总和。
3. 仅有一个异或运算符：对每个可能的异或位置，计算左右两侧加减表达式的总和，再异或，最后累加所有位置的结果。

证明:
 1. 全是异或运算符的贡献
当所有相邻数字间均为异或时，表达式唯一，即 a1⊕a2⊕⋯⊕an。其贡献为该异或结果。
 2. 全是加减运算符的贡献
需计算所有可能的加减表达式的总和。通过归纳法证明：
 结论：对于 n 个数 a1,a2,…,an，所有加减表达式的总和为 a1×2^(n−1)。
 证明：
 当 n=1 时，仅有 a1，总和为 a1=a1×2^0，成立。
 假设 n=k 时成立（总和为 a1×2^(k−1)）。
当 n=k+1 时，每个 n=k 的表达式可扩展为 T+ak+1 和 T−ak+1，总和为 2×(a1×2^(k−1))=a1×2^k，即 n=k+1 时成立。
 归纳得证：全是加减时，总和为 a1×2^(n−1)。
翻译一下：全是加减时，对于每一种可能的情况，只有第一个数字（a1）对最终答案有贡献，其余数字会与其他情况正负相消，且有2^(n-1)种情况。
 3. 仅有一个异或运算符的贡献
设异或位于第 k 个位置（介于 ak 和 ak+1 之间）：
 左侧：a1,…,ak 的所有加减表达式总和为 S左=a1×2^(k−1)。
 右侧：ak+1,…,an 的所有加减表达式总和为 S右=ak+1×2^(n−k−1)。
 该位置的贡献为 S左⊕S右。
对所有 k=1,2,…,n−1 累加，即得此类情况的总贡献。

最终结果：总结果为上述三类贡献的总和，对 1e9+7 取余。
*/
#include <stdio.h>
const int MOD = 1e9 + 7;

long long qpow(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int n;
    scanf("%d",&n);
    int v[n + 1];
    long long ret = 0;
    for (int i = 1; i <= n; i++) {
    	scanf("%d",&v[i]);
    	ret ^= v[i];
	}
    ret = (ret + v[1] * qpow(2, n - 1) % MOD) % MOD;

    for (int i = 1; i < n; i++) {
        long long sl = v[1] * qpow(2, i - 1) % MOD;
        long long sr = v[i + 1] * qpow(2, n - i - 1) % MOD;
        ret = (ret + (sl ^ sr)) % MOD;
    }

    printf("%lld\n", ret % MOD);
    return 0;
}